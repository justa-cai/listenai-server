<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ListenAI V1.1 - Decoupled Client</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        h1 { text-align: center; color: #4fc3f7; margin-bottom: 10px; font-size: 1.8em; }
        .subtitle { text-align: center; color: #888; margin-bottom: 20px; font-size: 0.9em; }
        
        .connection-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        @media (max-width: 900px) {
            .connection-grid { grid-template-columns: 1fr; }
        }
        
        .conn-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .conn-panel h3 {
            color: #81d4fa;
            margin-bottom: 10px;
            font-size: 1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .conn-panel input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 13px;
            margin-bottom: 10px;
        }
        .conn-panel .status-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ef5350;
        }
        .status-dot.connected { background: #66bb6a; animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
        }
        .btn-primary { background: #4fc3f7; color: #1a1a2e; }
        .btn-primary:hover { background: #81d4fa; }
        .btn-danger { background: #ef5350; color: #fff; }
        .btn-danger:hover { background: #ff8a80; }
        .btn-success { background: #66bb6a; color: #fff; }
        .btn-success:hover { background: #81c784; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 280px;
            gap: 20px;
        }
        @media (max-width: 900px) {
            .main-content { grid-template-columns: 1fr; }
        }
        
        .messages-panel {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 15px;
            height: calc(100vh - 280px);
            overflow-y: auto;
        }
        @media (max-width: 900px) {
            .messages-panel { min-height: 400px; max-height: 50vh; }
        }
        
        .message {
            padding: 10px 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            font-size: 13px;
        }
        .message-system { background: rgba(79, 195, 247, 0.2); border-left: 3px solid #4fc3f7; }
        .message-asr { background: rgba(171, 71, 188, 0.2); border-left: 3px solid #ab47bc; }
        .message-llm { background: rgba(255, 167, 38, 0.2); border-left: 3px solid #ffa726; }
        .message-error { background: rgba(239, 83, 80, 0.2); border-left: 3px solid #ef5350; }
        .message-tool { background: rgba(102, 187, 106, 0.2); border-left: 3px solid #66bb6a; }
        .message-tts { background: rgba(3, 169, 244, 0.2); border-left: 3px solid #03a9f4; }
        .message-time { font-size: 11px; color: #888; margin-bottom: 5px; }
        
        .controls-panel { display: flex; flex-direction: column; gap: 15px; }
        
        .record-section { text-align: center; }
        .record-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 4px solid #66bb6a;
            background: rgba(102, 187, 106, 0.2);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 15px;
        }
        .record-btn:hover { background: rgba(102, 187, 106, 0.4); }
        .record-btn.recording { border-color: #ef5350; background: rgba(239, 83, 80, 0.3); animation: recording-pulse 1s infinite; }
        @keyframes recording-pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        .record-btn svg { width: 30px; height: 30px; fill: #66bb6a; }
        .record-btn.recording svg { fill: #ef5350; }
        .visualizer { height: 50px; background: rgba(0, 0, 0, 0.3); border-radius: 8px; margin-bottom: 10px; }
        
        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .panel h3 { color: #81d4fa; margin-bottom: 10px; font-size: 1em; }
        
        .option-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .option-row:last-child { border-bottom: none; }
        .option-row label { font-size: 12px; color: #888; }
        .toggle-switch {
            position: relative;
            width: 40px;
            height: 20px;
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            transition: 0.3s;
        }
        .toggle-slider::before {
            position: absolute;
            content: '';
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background: white;
            border-radius: 50%;
            transition: 0.3s;
        }
        .toggle-switch input:checked + .toggle-slider { background: #4fc3f7; }
        .toggle-switch input:checked + .toggle-slider::before { transform: translateX(20px); }
        
        .stats-panel {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        .stat-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value { font-size: 20px; font-weight: bold; color: #4fc3f7; }
        .stat-label { font-size: 10px; color: #888; margin-top: 3px; }
        
        .flow-indicator {
            text-align: center;
            padding: 10px;
            background: rgba(79, 195, 247, 0.1);
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 12px;
            color: #4fc3f7;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ListenAI V1.1</h1>
        <p class="subtitle">Decoupled Architecture - ASR | LLM | TTS</p>
        
        <div class="connection-grid">
            <div class="conn-panel">
                <h3>üé§ ASR Service</h3>
                <input type="text" id="asrUrl" value="ws://192.168.1.169:9200">
                <div class="status-row">
                    <span class="status-dot" id="asrStatusDot"></span>
                    <span id="asrStatusText" style="flex:1;font-size:12px;">Disconnected</span>
                    <button class="btn btn-primary" id="asrConnectBtn">Connect</button>
                </div>
            </div>
            
            <div class="conn-panel">
                <h3>ü§ñ LLM Gateway</h3>
                <input type="text" id="llmUrl" value="ws://192.168.1.169:9400">
                <div class="status-row">
                    <span class="status-dot" id="llmStatusDot"></span>
                    <span id="llmStatusText" style="flex:1;font-size:12px;">Disconnected</span>
                    <button class="btn btn-primary" id="llmConnectBtn">Connect</button>
                </div>
            </div>
            
            <div class="conn-panel">
                <h3>üîä TTS Service</h3>
                <input type="text" id="ttsUrl" value="ws://192.168.1.169:9300/tts">
                <div class="status-row">
                    <span class="status-dot" id="ttsStatusDot"></span>
                    <span id="ttsStatusText" style="flex:1;font-size:12px;">Disconnected</span>
                    <button class="btn btn-primary" id="ttsConnectBtn">Connect</button>
                </div>
            </div>
        </div>
        
        <div class="flow-indicator" id="flowIndicator">
            Ready - Connect all services to start
        </div>
        
        <div class="main-content">
            <div class="messages-panel" id="messagesPanel"></div>
            
            <div class="controls-panel">
                <div class="panel record-section">
                    <h3>Voice Input</h3>
                    <canvas class="visualizer" id="visualizer"></canvas>
                    <button class="record-btn" id="recordBtn">
                        <svg viewBox="0 0 24 24">
                            <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.91-3c-.49 0-.9.36-.98.85C16.52 14.2 14.47 16 12 16s-4.52-1.8-4.93-4.15c-.08-.49-.49-.85-.98-.85-.61 0-1.09.54-1 1.14.49 3 2.89 5.35 5.91 5.78V20c0 .55.45 1 1 1s1-.45 1-1v-2.08c3.02-.43 5.42-2.78 5.91-5.78.1-.6-.39-1.14-1-1.14z"/>
                        </svg>
                    </button>
                    <p id="recordingStatus" style="font-size:12px;">Click to start recording</p>
                </div>
                
                <div class="panel">
                    <h3>Options</h3>
                    <div class="option-row">
                        <label>Auto TTS playback</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="autoTtsToggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="option-row">
                        <label>Auto send to LLM</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="autoLlmToggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div style="margin-top:10px;">
                        <label style="font-size:11px;color:#888;">Voice Selection</label>
                        <select id="voiceSelect" style="width:100%;margin-top:5px;padding:6px 10px;border-radius:6px;background:rgba(0,0,0,0.3);border:1px solid rgba(255,255,255,0.2);color:#fff;font-size:12px;">
                            <option value="ÂÖ®ÈÉ®-ÊπæÊπæÂ∞è‰Ωï" selected>ÊπæÊπæÂ∞è‰Ωï</option>
                            <option value="ÈÄöÁî®Âú∫ÊôØ-ÁîúÁæéÊÇ¶ÊÇ¶">ÁîúÁæéÊÇ¶ÊÇ¶</option>
                            <option value="ÈÄöÁî®Âú∫ÊôØ-Èò≥ÂÖâÈùíÂπ¥">Èò≥ÂÖâÈùíÂπ¥</option>
                            <option value="ÈÄöÁî®Âú∫ÊôØ-Ê∏ÖÊñ∞Â•≥Â£∞">Ê∏ÖÊñ∞Â•≥Â£∞</option>
                            <option value="ÈÄöÁî®Âú∫ÊôØ-Ê∏©ÊöñÈòøËôé">Ê∏©ÊöñÈòøËôé</option>
                        </select>
                    </div>
                </div>
                
                <div class="panel">
                    <h3>Statistics</h3>
                    <div class="stats-panel">
                        <div class="stat-item">
                            <div class="stat-value" id="msgCount">0</div>
                            <div class="stat-label">Messages</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="toolCount">0</div>
                            <div class="stat-label">Tools</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="asrCount">0</div>
                            <div class="stat-label">ASR</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="ttsCount">0</div>
                            <div class="stat-label">TTS</div>
                        </div>
                    </div>
                    <button class="btn btn-danger" id="clearBtn" style="width:100%;margin-top:10px;">Clear Messages</button>
                </div>
                
                <button class="btn btn-primary" id="connectAllBtn" style="width:100%;padding:12px;font-size:14px;">Connect All Services</button>
            </div>
        </div>
    </div>

    <script>
        class ListenAIClient {
            constructor() {
                // WebSocket connections
                this.asrWs = null;
                this.llmWs = null;
                this.ttsWs = null;
                
                // Connection states
                this.asrConnected = false;
                this.llmConnected = false;
                this.ttsConnected = false;
                
                // Recording
                this.audioContext = null;
                this.analyser = null;
                this.scriptProcessor = null;
                this.mediaStream = null;
                this.isRecording = false;
                
                // TTS playback
                this.isPlaying = false;
                this.audioQueue = [];
                this.playbackContext = null;
                this._nextPlayTime = 0;
                
                // Stats
                this.stats = { messages: 0, tools: 0, asr: 0, tts: 0 };
                
                // Session
                this.sessionId = null;
                this.lastAsrText = '';
                
                this.initElements();
                this.initEventListeners();
                this.initVisualizer();
            }
            
            initElements() {
                // URLs
                this.asrUrlInput = document.getElementById('asrUrl');
                this.llmUrlInput = document.getElementById('llmUrl');
                this.ttsUrlInput = document.getElementById('ttsUrl');
                
                // Status indicators
                this.asrStatusDot = document.getElementById('asrStatusDot');
                this.llmStatusDot = document.getElementById('llmStatusDot');
                this.ttsStatusDot = document.getElementById('ttsStatusDot');
                this.asrStatusText = document.getElementById('asrStatusText');
                this.llmStatusText = document.getElementById('llmStatusText');
                this.ttsStatusText = document.getElementById('ttsStatusText');
                
                // Buttons
                this.asrConnectBtn = document.getElementById('asrConnectBtn');
                this.llmConnectBtn = document.getElementById('llmConnectBtn');
                this.ttsConnectBtn = document.getElementById('ttsConnectBtn');
                this.connectAllBtn = document.getElementById('connectAllBtn');
                this.recordBtn = document.getElementById('recordBtn');
                this.clearBtn = document.getElementById('clearBtn');
                
                // Options
                this.autoTtsToggle = document.getElementById('autoTtsToggle');
                this.autoLlmToggle = document.getElementById('autoLlmToggle');
                this.voiceSelect = document.getElementById('voiceSelect');
                
                // Other
                this.messagesPanel = document.getElementById('messagesPanel');
                this.visualizerCanvas = document.getElementById('visualizer');
                this.flowIndicator = document.getElementById('flowIndicator');
                this.recordingStatus = document.getElementById('recordingStatus');
            }
            
            initEventListeners() {
                this.asrConnectBtn.addEventListener('click', () => this.connectASR());
                this.llmConnectBtn.addEventListener('click', () => this.connectLLM());
                this.ttsConnectBtn.addEventListener('click', () => this.connectTTS());
                this.connectAllBtn.addEventListener('click', () => this.connectAll());
                this.recordBtn.addEventListener('click', () => this.toggleRecording());
                this.clearBtn.addEventListener('click', () => this.clearMessages());
            }
            
            initVisualizer() {
                const canvas = this.visualizerCanvas;
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                const draw = () => {
                    requestAnimationFrame(draw);
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    if (this.analyser && this.isRecording) {
                        const bufferLength = this.analyser.frequencyBinCount;
                        const dataArray = new Uint8Array(bufferLength);
                        this.analyser.getByteFrequencyData(dataArray);
                        
                        const barWidth = (canvas.width / bufferLength) * 2.5;
                        let x = 0;
                        
                        for (let i = 0; i < bufferLength; i++) {
                            const barHeight = (dataArray[i] / 255) * canvas.height;
                            ctx.fillStyle = `rgba(79, 195, 247, ${dataArray[i] / 255})`;
                            ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                            x += barWidth + 1;
                        }
                    }
                };
                draw();
            }
            
            updateFlowIndicator() {
                const allConnected = this.asrConnected && this.llmConnected && this.ttsConnected;
                const anyConnected = this.asrConnected || this.llmConnected || this.ttsConnected;
                
                if (allConnected) {
                    this.flowIndicator.textContent = '‚úì All services connected - Ready to record';
                    this.flowIndicator.style.background = 'rgba(102, 187, 106, 0.2)';
                } else if (anyConnected) {
                    const missing = [];
                    if (!this.asrConnected) missing.push('ASR');
                    if (!this.llmConnected) missing.push('LLM');
                    if (!this.ttsConnected) missing.push('TTS');
                    this.flowIndicator.textContent = `‚ö† Missing: ${missing.join(', ')}`;
                    this.flowIndicator.style.background = 'rgba(255, 167, 38, 0.2)';
                } else {
                    this.flowIndicator.textContent = 'Ready - Connect services to start';
                    this.flowIndicator.style.background = 'rgba(79, 195, 247, 0.1)';
                }
            }
            
            // ========== ASR Connection ==========
            async connectASR() {
                if (this.asrConnected) {
                    this.disconnectASR();
                    return;
                }
                
                const url = this.asrUrlInput.value;
                this.addMessage('system', `Connecting to ASR: ${url}`);
                
                try {
                    this.asrWs = new WebSocket(url);
                    this.asrWs.binaryType = 'arraybuffer';
                    
                    this.asrWs.onopen = () => {
                        this.asrConnected = true;
                        this.updateASRStatus(true);
                        this.addMessage('system', 'ASR connected');
                        this.updateFlowIndicator();
                    };
                    
                    this.asrWs.onmessage = (event) => {
                        this.handleASRMessage(event.data);
                    };
                    
                    this.asrWs.onclose = () => {
                        this.asrConnected = false;
                        this.updateASRStatus(false);
                        this.addMessage('system', 'ASR disconnected');
                        this.updateFlowIndicator();
                    };
                    
                    this.asrWs.onerror = (error) => {
                        this.addMessage('error', 'ASR connection error');
                    };
                } catch (error) {
                    this.addMessage('error', `ASR connection failed: ${error.message}`);
                }
            }
            
            disconnectASR() {
                if (this.asrWs) {
                    this.asrWs.close();
                    this.asrWs = null;
                }
                this.asrConnected = false;
                this.updateASRStatus(false);
                this.updateFlowIndicator();
            }
            
            updateASRStatus(connected) {
                this.asrStatusDot.classList.toggle('connected', connected);
                this.asrStatusText.textContent = connected ? 'Connected' : 'Disconnected';
                this.asrConnectBtn.textContent = connected ? 'Disconnect' : 'Connect';
                this.asrConnectBtn.className = connected ? 'btn btn-danger' : 'btn btn-primary';
                this.updateConnectAllButton();
            }
            
            handleASRMessage(data) {
                try {
                    let message;
                    if (data instanceof ArrayBuffer) {
                        message = JSON.parse(new TextDecoder().decode(data));
                    } else if (typeof data === 'string') {
                        message = JSON.parse(data);
                    } else {
                        console.warn('Unknown ASR message type:', typeof data);
                        return;
                    }
                    
                    const text = message.text || '';
                    const isFinal = message.is_final || false;
                    
                    this.stats.asr++;
                    this.updateStats();
                    
                    this.addMessage('asr', `[ASR] ${isFinal ? 'Final' : 'Partial'}: ${text}`);
                    
                    if (isFinal && text) {
                        this.lastAsrText = text;
                        
                        if (this.autoLlmToggle.checked && this.llmConnected) {
                            this.sendToLLM(text);
                        }
                    }
                } catch (e) {
                    console.error('Failed to parse ASR message:', e);
                }
            }
            
            // ========== LLM Connection ==========
            async connectLLM() {
                if (this.llmConnected) {
                    this.disconnectLLM();
                    return;
                }
                
                const url = this.llmUrlInput.value;
                this.addMessage('system', `Connecting to LLM Gateway: ${url}`);
                
                try {
                    this.llmWs = new WebSocket(url);
                    
                    this.llmWs.onopen = () => {
                        this.llmConnected = true;
                        this.updateLLMStatus(true);
                        this.addMessage('system', 'LLM Gateway connected');
                        this.updateFlowIndicator();
                    };
                    
                    this.llmWs.onmessage = (event) => {
                        this.handleLLMMessage(JSON.parse(event.data));
                    };
                    
                    this.llmWs.onclose = () => {
                        this.llmConnected = false;
                        this.updateLLMStatus(false);
                        this.addMessage('system', 'LLM Gateway disconnected');
                        this.updateFlowIndicator();
                    };
                    
                    this.llmWs.onerror = (error) => {
                        this.addMessage('error', 'LLM connection error');
                    };
                } catch (error) {
                    this.addMessage('error', `LLM connection failed: ${error.message}`);
                }
            }
            
            disconnectLLM() {
                if (this.llmWs) {
                    this.llmWs.close();
                    this.llmWs = null;
                }
                this.llmConnected = false;
                this.updateLLMStatus(false);
                this.updateFlowIndicator();
            }
            
            updateLLMStatus(connected) {
                this.llmStatusDot.classList.toggle('connected', connected);
                this.llmStatusText.textContent = connected ? 'Connected' : 'Disconnected';
                this.llmConnectBtn.textContent = connected ? 'Disconnect' : 'Connect';
                this.llmConnectBtn.className = connected ? 'btn btn-danger' : 'btn btn-primary';
                this.updateConnectAllButton();
            }
            
            handleLLMMessage(data) {
                const type = data.type;
                this.stats.messages++;
                this.updateStats();
                
                switch (type) {
                    case 'status':
                        if (data.status === 'connected') {
                            this.sessionId = data.data?.session_id;
                            this.addMessage('system', `Session: ${this.sessionId}`);
                        } else {
                            this.addMessage('system', `[Status] ${data.status}`);
                        }
                        break;
                    case 'llm_response':
                        this.addMessage('llm', `[LLM] ${data.content}`);
                        if (this.autoTtsToggle.checked && data.content && this.ttsConnected) {
                            this.sendToTTS(data.content);
                        }
                        break;
                    case 'tool_call':
                        this.stats.tools++;
                        this.updateStats();
                        this.addMessage('tool', `[Tool] ${data.tool_name}(${JSON.stringify(data.arguments)}) -> ${JSON.stringify(data.result)}`);
                        break;
                    case 'error':
                        this.addMessage('error', `[Error] ${data.code}: ${data.message}`);
                        break;
                    case 'pong':
                        this.addMessage('system', '[Pong] LLM Gateway responded');
                        break;
                }
            }
            
            sendToLLM(text) {
                if (!this.llmConnected || !this.llmWs) {
                    this.addMessage('error', 'LLM not connected');
                    return;
                }
                
                const message = {
                    type: 'text_input',
                    text: text,
                    session_id: this.sessionId
                };
                
                this.llmWs.send(JSON.stringify(message));
                this.addMessage('system', `[Sent to LLM] ${text.substring(0, 50)}...`);
            }
            
            // ========== TTS Connection ==========
            async connectTTS() {
                if (this.ttsConnected) {
                    this.disconnectTTS();
                    return;
                }
                
                const url = this.ttsUrlInput.value;
                this.addMessage('system', `Connecting to TTS: ${url}`);
                
                try {
                    this.ttsWs = new WebSocket(url);
                    this.ttsWs.binaryType = 'arraybuffer';
                    
                    this.ttsWs.onopen = () => {
                        this.ttsConnected = true;
                        this.updateTTSStatus(true);
                        this.addMessage('system', 'TTS connected');
                        this.updateFlowIndicator();
                    };
                    
                    this.ttsWs.onmessage = (event) => {
                        if (event.data instanceof ArrayBuffer) {
                            this.handleTTSAudio(event.data);
                        } else {
                            this.handleTTSMessage(JSON.parse(event.data));
                        }
                    };
                    
                    this.ttsWs.onclose = () => {
                        this.ttsConnected = false;
                        this.updateTTSStatus(false);
                        this.addMessage('system', 'TTS disconnected');
                        this.updateFlowIndicator();
                    };
                    
                    this.ttsWs.onerror = (error) => {
                        this.addMessage('error', 'TTS connection error');
                    };
                } catch (error) {
                    this.addMessage('error', `TTS connection failed: ${error.message}`);
                }
            }
            
            disconnectTTS() {
                if (this.ttsWs) {
                    this.ttsWs.close();
                    this.ttsWs = null;
                }
                this.ttsConnected = false;
                this.updateTTSStatus(false);
                this.updateFlowIndicator();
            }
            
            updateTTSStatus(connected) {
                this.ttsStatusDot.classList.toggle('connected', connected);
                this.ttsStatusText.textContent = connected ? 'Connected' : 'Disconnected';
                this.ttsConnectBtn.textContent = connected ? 'Disconnect' : 'Connect';
                this.ttsConnectBtn.className = connected ? 'btn btn-danger' : 'btn btn-primary';
                this.updateConnectAllButton();
            }
            
            handleTTSMessage(data) {
                const type = data.type;
                
                switch (type) {
                    case 'complete':
                        this.addMessage('tts', '[TTS] Synthesis complete');
                        break;
                    case 'error':
                        this.addMessage('error', `[TTS Error] ${data.error?.message || 'Unknown error'}`);
                        break;
                    case 'progress':
                        this.addMessage('tts', `[TTS] ${data.state} - ${data.message || ''}`);
                        break;
                }
            }
            
            handleTTSAudio(data) {
                const parsed = this.parseTTSFrame(data);
                if (parsed && parsed.audio && parsed.audio.length > 0) {
                    this.stats.tts++;
                    this.updateStats();
                    
                    const chunk = {
                        data: parsed.audio,
                        sampleRate: parsed.sampleRate || 16000
                    };
                    
                    if (!this.playbackContext) {
                        this.playbackContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    if (this.playbackContext.state === 'suspended') {
                        this.playbackContext.resume();
                    }
                    
                    if (!this.isPlaying) {
                        this.isPlaying = true;
                        this._nextPlayTime = this.playbackContext.currentTime;
                        this.addMessage('tts', '[TTS] Playing audio...');
                    }
                    
                    this.audioQueue.push(chunk);
                    
                    while (this.audioQueue.length > 0) {
                        const currentChunk = this.audioQueue.shift();
                        const audioData = currentChunk.data;
                        const sampleRate = currentChunk.sampleRate || 16000;
                        
                        if (!audioData || audioData.length === 0) {
                            continue;
                        }
                        
                        const float32Buffer = new Float32Array(audioData.length);
                        for (let i = 0; i < audioData.length; i++) {
                            float32Buffer[i] = audioData[i] / 32768.0;
                        }
                        
                        const audioBuffer = this.playbackContext.createBuffer(1, float32Buffer.length, sampleRate);
                        audioBuffer.getChannelData(0).set(float32Buffer);
                        
                        let startTime = this._nextPlayTime;
                        const currentTime = this.playbackContext.currentTime;
                        if (startTime < currentTime) {
                            startTime = currentTime;
                        }
                        
                        const source = this.playbackContext.createBufferSource();
                        source.buffer = audioBuffer;
                        source.connect(this.playbackContext.destination);
                        source.start(startTime);
                        
                        this._nextPlayTime = startTime + audioBuffer.duration;
                    }
                    
                } else if (parsed && parsed.metadata) {
                    if (parsed.metadata.is_final) {
                        this.isPlaying = false;
                        this.addMessage('tts', '[TTS] Audio stream complete');
                    }
                }
            }
            
            parseTTSFrame(buffer) {
                try {
                    const view = new DataView(buffer);
                    
                    if (buffer.byteLength < 8) {
                        console.warn('TTS frame too short:', buffer.byteLength);
                        return null;
                    }
                    
                    const magic = view.getUint16(0, false);
                    if (magic !== 0xAA55) {
                        console.warn('TTS frame invalid magic:', magic.toString(16));
                        return null;
                    }
                    
                    const msgType = view.getUint8(2);
                    const metadataLength = view.getUint32(4, false);
                    
                    console.log('TTS frame: magic=0x' + magic.toString(16) + ', msgType=' + msgType + ', metaLen=' + metadataLength + ', totalLen=' + buffer.byteLength);
                    
                    if (buffer.byteLength < 8 + metadataLength + 4) {
                        console.warn('TTS frame incomplete');
                        return null;
                    }
                    
                    const metadataBytes = new Uint8Array(buffer, 8, metadataLength);
                    const metadata = JSON.parse(new TextDecoder().decode(metadataBytes));
                    
                    console.log('TTS metadata:', metadata);
                    
                    const payloadLengthOffset = 8 + metadataLength;
                    const payloadLength = view.getUint32(payloadLengthOffset, false);
                    const audioDataOffset = payloadLengthOffset + 4;
                    
                    console.log('TTS payload: length=' + payloadLength + ', offset=' + audioDataOffset);
                    
                    if (payloadLength === 0) {
                        return {
                            metadata: metadata,
                            audio: null,
                            sampleRate: metadata.sample_rate || 16000
                        };
                    }
                    
                    const audioDataBytes = new Uint8Array(buffer, audioDataOffset, payloadLength);
                    
                    const audioData = new Int16Array(audioDataBytes.length / 2);
                    for (let i = 0; i < audioData.length; i++) {
                        const lowByte = audioDataBytes[i * 2];
                        const highByte = audioDataBytes[i * 2 + 1];
                        audioData[i] = lowByte | (highByte << 8);
                    }
                    
                    console.log('TTS audio: samples=' + audioData.length + ', sampleRate=' + (metadata.sample_rate || 16000));
                    
                    return {
                        metadata: metadata,
                        audio: audioData,
                        sampleRate: metadata.sample_rate || 16000
                    };
                } catch (e) {
                    console.error('Failed to parse TTS frame:', e);
                    return null;
                }
            }
            
            scheduleChunk(chunk) {
                const audioData = chunk.data;
                const sampleRate = chunk.sampleRate || 16000;
                
                if (!audioData || audioData.length === 0) {
                    return;
                }
                
                const float32Buffer = new Float32Array(audioData.length);
                for (let i = 0; i < audioData.length; i++) {
                    float32Buffer[i] = audioData[i] / 32768.0;
                }
                
                const audioBuffer = this.playbackContext.createBuffer(1, float32Buffer.length, sampleRate);
                audioBuffer.getChannelData(0).set(float32Buffer);
                
                let startTime = this._nextPlayTime;
                const currentTime = this.playbackContext.currentTime;
                if (startTime < currentTime) {
                    startTime = currentTime;
                }
                
                const source = this.playbackContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(this.playbackContext.destination);
                source.start(startTime);
                
                this._nextPlayTime = startTime + audioBuffer.duration;
                
                source.onended = () => {
                    if (this.audioQueue.length > 0) {
                        const nextChunk = this.audioQueue.shift();
                        this.scheduleChunk(nextChunk);
                    } else {
                        this.isPlaying = false;
                    }
                };
            }
            
            startStreamingPlayback() {
                if (!this.playbackContext) {
                    this.playbackContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                if (this.playbackContext.state === 'suspended') {
                    this.playbackContext.resume();
                }
                
                this.isPlaying = true;
                this._nextPlayTime = this.playbackContext.currentTime;
                
                if (this.audioQueue.length > 0) {
                    const firstChunk = this.audioQueue.shift();
                    this.scheduleChunk(firstChunk);
                }
            }
            
            sendToTTS(text) {
                if (!this.ttsConnected || !this.ttsWs) {
                    this.addMessage('error', 'TTS not connected');
                    return;
                }
                
                const voiceId = this.voiceSelect.value || 'ÂÖ®ÈÉ®-ÊπæÊπæÂ∞è‰Ωï';
                const request = {
                    type: 'tts_request',
                    request_id: crypto.randomUUID(),
                    params: {
                        text: text,
                        mode: 'streaming',
                        voice_id: voiceId
                    }
                };
                
                this.ttsWs.send(JSON.stringify(request));
                this.addMessage('tts', `[TTS] Request sent (${voiceId}): ${text.substring(0, 30)}...`);
            }
            
            // ========== Recording ==========
            async toggleRecording() {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    await this.startRecording();
                }
            }
            
            async startRecording() {
                if (!this.asrConnected) {
                    this.addMessage('error', 'ASR not connected - cannot record');
                    return;
                }
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 16000
                        }
                    });
                    
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 16000
                    });
                    
                    this.analyser = this.audioContext.createAnalyser();
                    const source = this.audioContext.createMediaStreamSource(stream);
                    source.connect(this.analyser);
                    this.analyser.fftSize = 256;
                    
                    const bufferSize = 4096;
                    this.scriptProcessor = this.audioContext.createScriptProcessor(bufferSize, 1, 1);
                    source.connect(this.scriptProcessor);
                    this.scriptProcessor.connect(this.audioContext.destination);
                    
                    this.scriptProcessor.onaudioprocess = (e) => {
                        if (this.isRecording && this.asrWs && this.asrWs.readyState === WebSocket.OPEN) {
                            const inputData = e.inputBuffer.getChannelData(0);
                            const pcmData = this.float32ToInt16(inputData);
                            this.asrWs.send(pcmData);
                        }
                    };
                    
                    this.mediaStream = stream;
                    this.isRecording = true;
                    this.recordBtn.classList.add('recording');
                    this.recordingStatus.textContent = 'Recording... Click to stop';
                    
                } catch (error) {
                    this.addMessage('error', `Microphone access denied: ${error.message}`);
                }
            }
            
            stopRecording() {
                if (this.mediaStream) {
                    this.mediaStream.getTracks().forEach(track => track.stop());
                }
                if (this.scriptProcessor) {
                    this.scriptProcessor.disconnect();
                }
                this.isRecording = false;
                this.recordBtn.classList.remove('recording');
                this.recordingStatus.textContent = 'Click to start recording';
            }
            
            float32ToInt16(float32Array) {
                const buffer = new ArrayBuffer(float32Array.length * 2);
                const view = new DataView(buffer);
                for (let i = 0; i < float32Array.length; i++) {
                    let s = Math.max(-1, Math.min(1, float32Array[i]));
                    view.setInt16(i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
                }
                return buffer;
            }
            
            // ========== Utilities ==========
            connectAll() {
                const allConnected = this.asrConnected && this.llmConnected && this.ttsConnected;
                
                if (allConnected) {
                    // Disconnect all
                    if (this.asrConnected) this.disconnectASR();
                    if (this.llmConnected) this.disconnectLLM();
                    if (this.ttsConnected) this.disconnectTTS();
                    this.connectAllBtn.textContent = 'Connect All Services';
                    this.connectAllBtn.className = 'btn btn-primary';
                } else {
                    // Connect all
                    if (!this.asrConnected) this.connectASR();
                    if (!this.llmConnected) this.connectLLM();
                    if (!this.ttsConnected) this.connectTTS();
                    this.connectAllBtn.textContent = 'Disconnect All Services';
                    this.connectAllBtn.className = 'btn btn-danger';
                }
            }
            
            updateConnectAllButton() {
                const allConnected = this.asrConnected && this.llmConnected && this.ttsConnected;
                if (allConnected) {
                    this.connectAllBtn.textContent = 'Disconnect All Services';
                    this.connectAllBtn.className = 'btn btn-danger';
                } else {
                    this.connectAllBtn.textContent = 'Connect All Services';
                    this.connectAllBtn.className = 'btn btn-primary';
                }
            }
            
            addMessage(type, text) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message message-${type}`;
                
                const timeDiv = document.createElement('div');
                timeDiv.className = 'message-time';
                timeDiv.textContent = new Date().toLocaleTimeString();
                
                const textDiv = document.createElement('div');
                textDiv.textContent = text;
                
                messageDiv.appendChild(timeDiv);
                messageDiv.appendChild(textDiv);
                
                this.messagesPanel.appendChild(messageDiv);
                this.messagesPanel.scrollTop = this.messagesPanel.scrollHeight;
            }
            
            updateStats() {
                document.getElementById('msgCount').textContent = this.stats.messages;
                document.getElementById('toolCount').textContent = this.stats.tools;
                document.getElementById('asrCount').textContent = this.stats.asr;
                document.getElementById('ttsCount').textContent = this.stats.tts;
            }
            
            clearMessages() {
                this.messagesPanel.innerHTML = '';
                this.stats = { messages: 0, tools: 0, asr: 0, tts: 0 };
                this.updateStats();
            }
        }
        
        const client = new ListenAIClient();
    </script>
</body>
</html>
